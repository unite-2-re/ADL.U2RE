function t(t){return(s,e)=>"object"==typeof e?U(t,s,e):((t,s,e)=>{const i=s.hasOwnProperty(e);return s.constructor.createProperty(e,i?{...t,wrapped:1}:t),i?Object.getOwnPropertyDescriptor(s,e):void 0})(t,s,e)}const s=globalThis,e=s.ShadowRoot&&(void 0===s.ShadyCSS||s.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,i=Symbol(),o=new WeakMap;let r=class{constructor(t,s,e){if(this._$cssResult$=1,e!==i)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=t,this.t=s}get styleSheet(){let t=this.o;const s=this.t;if(e&&void 0===t){const e=void 0!==s&&1===s.length;e&&(t=o.get(s)),void 0===t&&((this.o=t=new CSSStyleSheet).replaceSync(this.cssText),e&&o.set(s,t))}return t}toString(){return this.cssText}};const n=t=>new r("string"==typeof t?t:t+"",void 0,i),h=(t,...s)=>{const e=1===t.length?t[0]:s.reduce(((s,e,i)=>s+(t=>{if(1==t._$cssResult$)return t.cssText;if("number"==typeof t)return t;throw Error("Value passed to 'css' function must be a 'css' function result: "+t+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(e)+t[i+1]),t[0]);return new r(e,t,i)},a=e?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let s="";for(const e of t.cssRules)s+=e.cssText;return n(s)})(t):t,{is:c,defineProperty:l,getOwnPropertyDescriptor:u,getOwnPropertyNames:d,getOwnPropertySymbols:f,getPrototypeOf:p}=Object,S=globalThis,y=S.trustedTypes,b=y?y.emptyScript:"",v=S.reactiveElementPolyfillSupport,m=(t,s)=>t,w={toAttribute(t,s){switch(s){case Boolean:t=t?b:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t)}return t},fromAttribute(t,s){let e=t;switch(s){case Boolean:e=null!==t;break;case Number:e=null===t?null:+t;break;case Object:case Array:try{e=JSON.parse(t)}catch(t){e=null}}return e}},g=(t,s)=>!c(t,s),C={attribute:1,type:String,converter:w,reflect:0,hasChanged:g};Symbol.metadata??=Symbol(),S.litPropertyMetadata??=new WeakMap;class E extends HTMLElement{static addInitializer(t){this._$Ei(),(this.l??=[]).push(t)}static get observedAttributes(){return this.finalize(),this._$Eh&&[...this._$Eh.keys()]}static createProperty(t,s=C){if(s.state&&(s.attribute=0),this._$Ei(),this.elementProperties.set(t,s),!s.noAccessor){const e=Symbol(),i=this.getPropertyDescriptor(t,e,s);void 0!==i&&l(this.prototype,t,i)}}static getPropertyDescriptor(t,s,e){const{get:i,set:o}=u(this.prototype,t)??{get(){return this[s]},set(t){this[s]=t}};return{get(){return i?.call(this)},set(s){const r=i?.call(this);o.call(this,s),this.requestUpdate(t,r,e)},configurable:1,enumerable:1}}static getPropertyOptions(t){return this.elementProperties.get(t)??C}static _$Ei(){if(this.hasOwnProperty(m("elementProperties")))return;const t=p(this);t.finalize(),void 0!==t.l&&(this.l=[...t.l]),this.elementProperties=new Map(t.elementProperties)}static finalize(){if(this.hasOwnProperty(m("finalized")))return;if(this.finalized=1,this._$Ei(),this.hasOwnProperty(m("properties"))){const t=this.properties,s=[...d(t),...f(t)];for(const e of s)this.createProperty(e,t[e])}const t=this[Symbol.metadata];if(null!==t){const s=litPropertyMetadata.get(t);if(void 0!==s)for(const[t,e]of s)this.elementProperties.set(t,e)}this._$Eh=new Map;for(const[t,s]of this.elementProperties){const e=this._$Eu(t,s);void 0!==e&&this._$Eh.set(e,t)}this.elementStyles=this.finalizeStyles(this.styles)}static finalizeStyles(t){const s=[];if(Array.isArray(t)){const e=new Set(t.flat(1/0).reverse());for(const t of e)s.unshift(a(t))}else void 0!==t&&s.push(a(t));return s}static _$Eu(t,s){const e=s.attribute;return 0==e?void 0:"string"==typeof e?e:"string"==typeof t?t.toLowerCase():void 0}constructor(){super(),this._$Ep=void 0,this.isUpdatePending=0,this.hasUpdated=0,this._$Em=null,this._$Ev()}_$Ev(){this._$ES=new Promise((t=>this.enableUpdating=t)),this._$AL=new Map,this._$E_(),this.requestUpdate(),this.constructor.l?.forEach((t=>t(this)))}addController(t){(this._$EO??=new Set).add(t),void 0!==this.renderRoot&&this.isConnected&&t.hostConnected?.()}removeController(t){this._$EO?.delete(t)}_$E_(){const t=new Map,s=this.constructor.elementProperties;for(const e of s.keys())this.hasOwnProperty(e)&&(t.set(e,this[e]),delete this[e]);t.size>0&&(this._$Ep=t)}createRenderRoot(){const t=this.shadowRoot??this.attachShadow(this.constructor.shadowRootOptions);return((t,i)=>{if(e)t.adoptedStyleSheets=i.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet));else for(const e of i){const i=document.createElement("style"),o=s.litNonce;void 0!==o&&i.setAttribute("nonce",o),i.textContent=e.cssText,t.appendChild(i)}})(t,this.constructor.elementStyles),t}connectedCallback(){this.renderRoot??=this.createRenderRoot(),this.enableUpdating(1),this._$EO?.forEach((t=>t.hostConnected?.()))}enableUpdating(t){}disconnectedCallback(){this._$EO?.forEach((t=>t.hostDisconnected?.()))}attributeChangedCallback(t,s,e){this._$AK(t,e)}_$EC(t,s){const e=this.constructor.elementProperties.get(t),i=this.constructor._$Eu(t,e);if(void 0!==i&&1==e.reflect){const o=(void 0!==e.converter?.toAttribute?e.converter:w).toAttribute(s,e.type);this._$Em=t,null==o?this.removeAttribute(i):this.setAttribute(i,o),this._$Em=null}}_$AK(t,s){const e=this.constructor,i=e._$Eh.get(t);if(void 0!==i&&this._$Em!==i){const t=e.getPropertyOptions(i),o="function"==typeof t.converter?{fromAttribute:t.converter}:void 0!==t.converter?.fromAttribute?t.converter:w;this._$Em=i,this[i]=o.fromAttribute(s,t.type),this._$Em=null}}requestUpdate(t,s,e){if(void 0!==t){if(e??=this.constructor.getPropertyOptions(t),!(e.hasChanged??g)(this[t],s))return;this.P(t,s,e)}0==this.isUpdatePending&&(this._$ES=this._$ET())}P(t,s,e){this._$AL.has(t)||this._$AL.set(t,s),1==e.reflect&&this._$Em!==t&&(this._$Ej??=new Set).add(t)}async _$ET(){this.isUpdatePending=1;try{await this._$ES}catch(t){Promise.reject(t)}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){if(!this.isUpdatePending)return;if(!this.hasUpdated){if(this.renderRoot??=this.createRenderRoot(),this._$Ep){for(const[t,s]of this._$Ep)this[t]=s;this._$Ep=void 0}const t=this.constructor.elementProperties;if(t.size>0)for(const[s,e]of t)1!=e.wrapped||this._$AL.has(s)||void 0===this[s]||this.P(s,this[s],e)}let t=0;const s=this._$AL;try{t=this.shouldUpdate(s),t?(this.willUpdate(s),this._$EO?.forEach((t=>t.hostUpdate?.())),this.update(s)):this._$EU()}catch(s){throw t=0,this._$EU(),s}t&&this._$AE(s)}willUpdate(t){}_$AE(t){this._$EO?.forEach((t=>t.hostUpdated?.())),this.hasUpdated||(this.hasUpdated=1,this.firstUpdated(t)),this.updated(t)}_$EU(){this._$AL=new Map,this.isUpdatePending=0}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$ES}shouldUpdate(t){return 1}update(t){this._$Ej&&=this._$Ej.forEach((t=>this._$EC(t,this[t]))),this._$EU()}updated(t){}firstUpdated(t){}}E.elementStyles=[],E.shadowRootOptions={mode:"open"},E[m("elementProperties")]=new Map,E[m("finalized")]=new Map,v?.({ReactiveElement:E}),(S.reactiveElementVersions??=[]).push("2.0.4");const P=t=>(s,e)=>{void 0!==e?e.addInitializer((()=>{customElements.define(t,s)})):customElements.define(t,s)},M={attribute:1,type:String,converter:w,reflect:0,hasChanged:g},U=(t=M,s,e)=>{const{kind:i,metadata:o}=e;let r=globalThis.litPropertyMetadata.get(o);if(void 0===r&&globalThis.litPropertyMetadata.set(o,r=new Map),r.set(e.name,t),"accessor"===i){const{name:i}=e;return{set(e){const o=s.get.call(this);s.set.call(this,e),this.requestUpdate(i,o,t)},init(s){return void 0!==s&&this.P(i,void 0,t),s}}}if("setter"===i){const{name:i}=e;return function(e){const o=this[i];s.call(this,e),this.requestUpdate(i,o,t)}}throw Error("Unsupported decorator location: "+i)};export{E as b,h as i,t as n,n as r,P as t};